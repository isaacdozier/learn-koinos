"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serializer = void 0;
/* eslint-disable @typescript-eslint/require-await */
const protobufjs_1 = require("protobufjs");
const koinosPbToProto = __importStar(require("@roamin/koinos-pb-to-proto"));
const utils_1 = require("./utils");
const OP_BYTES_1 = "(btype)";
const OP_BYTES_2 = "(koinos.btype)";
const nativeTypes = [
    "double",
    "float",
    "int32",
    "int64",
    "uint32",
    "uint64",
    "sint32",
    "sint64",
    "fixed32",
    "fixed64",
    "sfixed32",
    "sfixed64",
    "bool",
    "string",
    "bytes",
];
/**
 * The serializer class serialize and deserialize data using
 * protocol buffers. It accepts the descriptor in JSON or binary format
 *
 * NOTE: This class uses the [protobufjs](https://www.npmjs.com/package/protobufjs)
 * library internally, which uses reflection (use of _eval_
 * and _new Function_) for the construction of the types.
 * This could cause issues in environments where _eval_ is not
 * allowed, like in browser extensions. In such cases, this class
 * must be confined in a [sandbox environment](https://developer.chrome.com/docs/apps/app_external/#sandboxing)
 * where _eval_ is allowed. This is the principal reason of
 * having the serializer in a separate class.
 *
 * @example
 *
 * ```ts
 * // using descriptor JSON
 * const descriptorJson = {
 *   nested: {
 *     awesomepackage: {
 *       nested: {
 *         AwesomeMessage: {
 *           fields: {
 *             awesome_field: {
 *               type: "string",
 *               id: 1,
 *             },
 *           },
 *         },
 *       },
 *     },
 *   },
 * };
 * const serializer1 = new Serializer(descriptorJson);
 * const message1 = await serializer1.deserialize(
 *   "CgZrb2lub3M=",
 *   "AwesomeMessage"
 * );
 * console.log(message1);
 * // { awesome_field: 'koinos' }
 *
 * // using descriptor binary
 * const descriptorBinary =
 *   "Cl4KDWF3ZXNvbWUucHJvdG8SDmF3ZXNvbWVwYWN" +
 *   "rYWdlIjUKDkF3ZXNvbWVNZXNzYWdlEiMKDWF3ZX" +
 *   "NvbWVfZmllbGQYASABKAlSDGF3ZXNvbWVGaWVsZ" +
 *   "GIGcHJvdG8z";
 * const serializer2 = new Serializer(descriptorBinary);
 * const message2 = await serializer2.deserialize(
 *   "CgZrb2lub3M=",
 *   "AwesomeMessage"
 * );
 * console.log(message2);
 * // { awesome_field: 'koinos' }
 * ```
 */
class Serializer {
    constructor(types, opts) {
        /**
         * Preformat bytes for base64url, base58 or hex string
         */
        this.bytesConversion = true;
        /**
         * Verify checksum in addresses during serialization
         * or deserialization
         */
        this.verifyChecksum = {
            serialize: true,
            deserialize: false,
        };
        this.types = types;
        if (typeof types === "string") {
            const protos = koinosPbToProto.convert((0, utils_1.decodeBase64)(types));
            this.root = new protobufjs_1.Root();
            for (const proto of protos) {
                (0, protobufjs_1.parse)(proto.definition, this.root, { keepCase: true });
            }
        }
        else {
            this.root = protobufjs_1.Root.fromJSON(types);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.defaultTypeName)
            this.defaultType = this.root.lookupType(opts.defaultTypeName);
        if (opts === null || opts === void 0 ? void 0 : opts.argumentsTypeName)
            this.argumentsTypeName = opts.argumentsTypeName;
        if (opts === null || opts === void 0 ? void 0 : opts.returnTypeName)
            this.returnTypeName = opts.returnTypeName;
        if (opts && typeof opts.bytesConversion !== "undefined")
            this.bytesConversion = opts.bytesConversion;
    }
    btypeDecode(valueBtypeEncoded, protobufType, verifyChecksum) {
        const valueBtypeDecoded = {};
        Object.keys(protobufType.fields).forEach((fieldName) => {
            // @ts-ignore
            const { options, name, type, rule } = protobufType.fields[fieldName];
            if (!valueBtypeEncoded[name])
                return;
            const typeField = { type };
            if (options) {
                if (options[OP_BYTES_1])
                    typeField.btype = options[OP_BYTES_1];
                else if (options[OP_BYTES_2])
                    typeField.btype = options[OP_BYTES_2];
            }
            // arrays
            if (rule === "repeated") {
                valueBtypeDecoded[name] = valueBtypeEncoded[name].map((itemEncoded) => {
                    // custom objects
                    if (!nativeTypes.includes(type)) {
                        const protoBuf = this.root.lookupTypeOrEnum(type);
                        if (!protoBuf.fields) {
                            // it's an enum
                            return itemEncoded;
                        }
                        return this.btypeDecode(itemEncoded, protoBuf, verifyChecksum);
                    }
                    // native types
                    return (0, utils_1.btypeDecodeValue)(itemEncoded, typeField, verifyChecksum);
                });
                return;
            }
            // custom objects
            if (!nativeTypes.includes(type)) {
                const protoBuf = this.root.lookupTypeOrEnum(type);
                if (!protoBuf.fields) {
                    // it's an enum
                    valueBtypeDecoded[name] = valueBtypeEncoded[name];
                    return;
                }
                valueBtypeDecoded[name] = this.btypeDecode(valueBtypeEncoded[name], protoBuf, verifyChecksum);
                return;
            }
            // native types
            valueBtypeDecoded[name] = (0, utils_1.btypeDecodeValue)(valueBtypeEncoded[name], typeField, verifyChecksum);
        });
        return valueBtypeDecoded;
    }
    btypeEncode(valueBtypeDecoded, protobufType, verifyChecksum) {
        const valueBtypeEncoded = {};
        Object.keys(protobufType.fields).forEach((fieldName) => {
            // @ts-ignore
            const { options, name, type, rule } = protobufType.fields[fieldName];
            if (!valueBtypeDecoded[name])
                return;
            const typeField = { type };
            if (options) {
                if (options[OP_BYTES_1])
                    typeField.btype = options[OP_BYTES_1];
                else if (options[OP_BYTES_2])
                    typeField.btype = options[OP_BYTES_2];
            }
            // arrays
            if (rule === "repeated") {
                valueBtypeEncoded[name] = valueBtypeDecoded[name].map((itemDecoded) => {
                    // custom objects
                    if (!nativeTypes.includes(type)) {
                        const protoBuf = this.root.lookupTypeOrEnum(type);
                        if (!protoBuf.fields) {
                            // it's an enum
                            return itemDecoded;
                        }
                        return this.btypeEncode(itemDecoded, protoBuf, verifyChecksum);
                    }
                    // native types
                    return (0, utils_1.btypeEncodeValue)(itemDecoded, typeField, verifyChecksum);
                });
                return;
            }
            // custom objects
            if (!nativeTypes.includes(type)) {
                const protoBuf = this.root.lookupTypeOrEnum(type);
                if (!protoBuf.fields) {
                    // it's an enum
                    valueBtypeEncoded[name] = valueBtypeDecoded[name];
                    return;
                }
                valueBtypeEncoded[name] = this.btypeEncode(valueBtypeDecoded[name], protoBuf, verifyChecksum);
                return;
            }
            // native types
            valueBtypeEncoded[name] = (0, utils_1.btypeEncodeValue)(valueBtypeDecoded[name], typeField, verifyChecksum);
        });
        return valueBtypeEncoded;
    }
    /**
     * Function to encode a type using the protobuffer definitions
     * It also prepares the bytes for special cases (base58, hex string)
     * when bytesConversion param is true.
     */
    async serialize(valueDecoded, typeName, opts) {
        let protobufType;
        if (this.defaultType)
            protobufType = this.defaultType;
        else if (!typeName)
            throw new Error("no typeName defined");
        else
            protobufType = this.root.lookupType(typeName);
        let object = {};
        const bytesConversion = (opts === null || opts === void 0 ? void 0 : opts.bytesConversion) === undefined
            ? this.bytesConversion
            : opts.bytesConversion;
        const verifyChecksum = (opts === null || opts === void 0 ? void 0 : opts.verifyChecksum) === undefined
            ? this.verifyChecksum.serialize
            : opts.verifyChecksum;
        if (bytesConversion) {
            object = this.btypeDecode(valueDecoded, protobufType, verifyChecksum);
        }
        else {
            object = valueDecoded;
        }
        const message = protobufType.create(object);
        const buffer = protobufType.encode(message).finish();
        return buffer;
    }
    /**
     * Function to decode bytes using the protobuffer definitions
     * It also encodes the bytes for special cases (base58, hex string)
     * when bytesConversion param is true.
     */
    async deserialize(valueEncoded, typeName, opts) {
        const valueBuffer = typeof valueEncoded === "string"
            ? (0, utils_1.decodeBase64url)(valueEncoded)
            : valueEncoded;
        let protobufType;
        if (this.defaultType)
            protobufType = this.defaultType;
        else if (!typeName)
            throw new Error("no typeName defined");
        else
            protobufType = this.root.lookupType(typeName);
        const message = protobufType.decode(valueBuffer);
        const object = protobufType.toObject(message, {
            longs: String,
            defaults: true,
        });
        const bytesConversion = (opts === null || opts === void 0 ? void 0 : opts.bytesConversion) === undefined
            ? this.bytesConversion
            : opts.bytesConversion;
        const verifyChecksum = (opts === null || opts === void 0 ? void 0 : opts.verifyChecksum) === undefined
            ? this.verifyChecksum.deserialize
            : opts.verifyChecksum;
        if (bytesConversion) {
            return this.btypeEncode(object, protobufType, verifyChecksum);
        }
        return object;
    }
}
exports.Serializer = Serializer;
exports.default = Serializer;
//# sourceMappingURL=Serializer.js.map