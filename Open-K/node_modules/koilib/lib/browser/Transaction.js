"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
/* eslint-disable no-param-reassign, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment */
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("./utils");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const protocol_proto_js_1 = require("./protoModules/protocol-proto.js");
const btypeTransactionHeader = {
    chain_id: { type: "bytes" },
    rc_limit: { type: "uint64" },
    nonce: { type: "bytes" },
    operation_merkle_root: { type: "bytes" },
    payer: { type: "bytes", btype: "ADDRESS" },
    payee: { type: "bytes", btype: "ADDRESS" },
};
const btypesOperation = {
    upload_contract: {
        type: "object",
        subtypes: {
            contract_id: { type: "bytes", btype: "CONTRACT_ID" },
            bytecode: { type: "bytes" },
            abi: { type: "string" },
            authorizes_call_contract: { type: "bool" },
            authorizes_transaction_application: { type: "bool" },
            authorizes_upload_contract: { type: "bool" },
        },
    },
    call_contract: {
        type: "object",
        subtypes: {
            contract_id: { type: "bytes", btype: "CONTRACT_ID" },
            entry_point: { type: "uint32" },
            args: { type: "bytes" },
        },
    },
    set_system_call: {
        type: "object",
        subtypes: {
            call_id: { type: "uint32" },
            target: {
                type: "object",
                subtypes: {
                    thunk_id: { type: "uint32" },
                    system_call_bundle: {
                        type: "object",
                        subtypes: {
                            contract_id: { type: "bytes", btype: "CONTRACT_ID" },
                            entry_point: { type: "uint32" },
                        },
                    },
                },
            },
        },
    },
    set_system_contract: {
        type: "object",
        subtypes: {
            contract_id: { type: "bytes", btype: "CONTRACT_ID" },
            system_contract: { type: "bool" },
        },
    },
};
class Transaction {
    constructor(c) {
        var _a, _b, _c, _d, _e, _f;
        this.signer = c === null || c === void 0 ? void 0 : c.signer;
        this.provider = (c === null || c === void 0 ? void 0 : c.provider) || ((_a = c === null || c === void 0 ? void 0 : c.signer) === null || _a === void 0 ? void 0 : _a.provider);
        this.options = {
            broadcast: true,
            sendAbis: true,
            ...c === null || c === void 0 ? void 0 : c.options,
        };
        this.transaction = {
            header: {
                ...(((_b = c === null || c === void 0 ? void 0 : c.options) === null || _b === void 0 ? void 0 : _b.chainId) && { chain_id: c.options.chainId }),
                ...(((_c = c === null || c === void 0 ? void 0 : c.options) === null || _c === void 0 ? void 0 : _c.rcLimit) && { rc_limit: c.options.rcLimit }),
                ...(((_d = c === null || c === void 0 ? void 0 : c.options) === null || _d === void 0 ? void 0 : _d.nonce) && { nonce: c.options.nonce }),
                ...(((_e = c === null || c === void 0 ? void 0 : c.options) === null || _e === void 0 ? void 0 : _e.payer) && { payer: c.options.payer }),
                ...(((_f = c === null || c === void 0 ? void 0 : c.options) === null || _f === void 0 ? void 0 : _f.payee) && { payee: c.options.payee }),
            },
            operations: [],
            ...c === null || c === void 0 ? void 0 : c.transaction,
        };
    }
    /**
     * Function to push an operation to the transaction. It can be created
     * in several ways. Example:
     *
     * @example
     * ```ts
     * const koin = new Contract({
     *   id: "15DJN4a8SgrbGhhGksSBASiSYjGnMU8dGL",
     *   abi: utils.tokenAbi,
     * }).functions;
     * const signer = Signer.fromSeed("my seed");
     * const provider = new Provider(["https://api.koinos.io"]);
     * signer.provider = provider;
     * const tx = new Transaction({ signer });
     *
     * // method 1
     * await tx.pushOperation(koin.transfer, {
     *   from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
     *   to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
     *   value: "1000",
     * });
     *
     * // method 2
     * await tx.pushOperation(
     *   koin.transfer({
     *     from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
     *     to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
     *     value: "1000",
     *   },{
     *    onlyOperation: true,
     *   })
     * );
     *
     * // method 3
     * await tx.pushOperation(
     *   await koin.transfer({
     *     from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
     *     to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
     *     value: "1000",
     *   },{
     *    onlyOperation: true,
     *   })
     * );
     *
     * // method 4
     * const { operation } = await koin.transfer({
     *   from: "1NRYHBYr9qxYQAeVqfdSvyjJemRQ4qD3Mt",
     *   to: "13UdKjYuzfBYbB6bGLQkUN9DJRFPCmG1mU",
     *   value: "1000",
     * },{
     *  onlyOperation: true,
     * });
     * await tx.pushOperation(operation)
     * ```
     *
     */
    async pushOperation(input, args) {
        let operation;
        if (typeof input === "function") {
            const result = await input(args, { onlyOperation: true });
            operation = result.operation;
        }
        else {
            let inp;
            if (input instanceof Promise) {
                inp = await input;
            }
            else {
                inp = input;
            }
            if (inp.operation) {
                operation = inp.operation;
            }
            else {
                operation = input;
            }
        }
        if (!this.transaction.operations)
            this.transaction.operations = [];
        this.transaction.operations.push(operation);
    }
    static computeTransactionId(txHeader) {
        const headerDecoded = (0, utils_1.btypeDecode)(txHeader, btypeTransactionHeader, false);
        const message = protocol_proto_js_1.koinos.protocol.transaction_header.create(headerDecoded);
        const headerBytes = protocol_proto_js_1.koinos.protocol.transaction_header
            .encode(message)
            .finish();
        const hash = (0, sha256_1.sha256)(headerBytes);
        // multihash 0x1220. 12: code sha2-256. 20: length (32 bytes)
        return `0x1220${(0, utils_1.toHexString)(hash)}`;
    }
    /**
     * Function to prepare a transaction
     * @param tx - Do not set the nonce to get it from the blockchain
     * using the provider. The rc_limit is 1e8 by default.
     * @param provider - Provider
     * @param payer - payer to be used in case it is not defined in the transaction
     * @returns A prepared transaction.
     */
    static async prepareTransaction(tx, provider, payer) {
        var _a;
        if (!tx.header) {
            tx.header = {};
        }
        const { payer: payerHeader, payee } = tx.header;
        if (!payerHeader)
            tx.header.payer = payer;
        payer = tx.header.payer;
        if (!payer)
            throw new Error("payer is undefined");
        let nonce;
        if (tx.header.nonce === undefined) {
            if (!provider)
                throw new Error("Cannot get the nonce because provider is undefined. To skip this call set a nonce in the transaction header");
            nonce = await provider.getNextNonce(payee || payer);
        }
        else {
            nonce = tx.header.nonce;
        }
        let rcLimit;
        if (tx.header.rc_limit === undefined) {
            if (!provider)
                throw new Error("Cannot get the rc_limit because provider is undefined. To skip this call set a rc_limit in the transaction header");
            rcLimit = await provider.getAccountRc(payer);
        }
        else {
            rcLimit = tx.header.rc_limit;
        }
        if (!tx.header.chain_id) {
            if (!provider)
                throw new Error("Cannot get the chain_id because provider is undefined. To skip this call set a chain_id");
            tx.header.chain_id = await provider.getChainId();
        }
        const operationsHashes = [];
        if (tx.operations) {
            for (let index = 0; index < ((_a = tx.operations) === null || _a === void 0 ? void 0 : _a.length); index += 1) {
                const operationDecoded = (0, utils_1.btypeDecode)(tx.operations[index], btypesOperation, false);
                const message = protocol_proto_js_1.koinos.protocol.operation.create(operationDecoded);
                const operationEncoded = protocol_proto_js_1.koinos.protocol.operation
                    .encode(message)
                    .finish();
                operationsHashes.push((0, sha256_1.sha256)(operationEncoded));
            }
        }
        const operationMerkleRoot = (0, utils_1.encodeBase64url)(new Uint8Array([
            // multihash sha256: 18, 32
            18,
            32,
            ...(0, utils_1.calculateMerkleRoot)(operationsHashes),
        ]));
        tx.header = {
            chain_id: tx.header.chain_id,
            rc_limit: rcLimit,
            nonce,
            operation_merkle_root: operationMerkleRoot,
            payer,
            ...(payee && { payee }),
            // TODO: Option to resolve names (payer, payee)
        };
        tx.id = Transaction.computeTransactionId(tx.header);
        return tx;
    }
    /**
     * Function to prepare the transaction (set headers, merkle
     * root, etc)
     */
    async prepare(options) {
        var _a;
        if (options) {
            const header = {
                ...((options === null || options === void 0 ? void 0 : options.chainId) && { chain_id: options.chainId }),
                ...((options === null || options === void 0 ? void 0 : options.rcLimit) && { rc_limit: options.rcLimit }),
                ...((options === null || options === void 0 ? void 0 : options.nonce) && { nonce: options.nonce }),
                ...((options === null || options === void 0 ? void 0 : options.payer) && { payer: options.payer }),
                ...((options === null || options === void 0 ? void 0 : options.payee) && { payee: options.payee }),
            };
            this.transaction.header = {
                ...this.transaction.header,
                ...header,
            };
        }
        this.transaction = await Transaction.prepareTransaction(this.transaction, this.provider, (_a = this.signer) === null || _a === void 0 ? void 0 : _a.getAddress());
        return this.transaction;
    }
    /**
     * Update the rc limit with a new value and update the
     * transaction ID accordingly. The signatures will be removed
     * if the transaction ID changed
     */
    adjustRcLimit(newRcLimit) {
        if (!this.transaction.header)
            throw new Error("transaction header not defined");
        this.transaction.header.rc_limit = newRcLimit;
        const newTxId = Transaction.computeTransactionId(this.transaction.header);
        if (this.transaction.id !== newTxId) {
            this.transaction.signatures = [];
        }
        this.transaction.id = newTxId;
    }
    /**
     * Function to sign the transaction
     */
    async sign(abis) {
        if (!this.signer)
            throw new Error("no signer defined");
        if (!this.transaction.id)
            await this.prepare();
        return this.signer.signTransaction(this.transaction, this.options.sendAbis ? abis : undefined);
    }
    /**
     * Function to broadcast the transaction
     */
    async send(options) {
        const opts = {
            ...this.options,
            ...options,
        };
        if (!this.transaction.id)
            await this.prepare();
        if (!this.transaction.signatures || !this.transaction.signatures.length) {
            if (!this.signer) {
                throw new Error("transaction without signatures and no signer defined");
            }
            const { transaction: tx, receipt } = await this.signer.sendTransaction(this.transaction, opts);
            this.transaction = tx;
            this.waitFunction = tx.wait;
            return receipt;
        }
        if (!this.provider)
            throw new Error("provider not defined");
        if (opts.beforeSend) {
            await opts.beforeSend(this.transaction, opts);
        }
        const { transaction: tx, receipt } = await this.provider.sendTransaction(this.transaction, opts.broadcast);
        this.transaction = tx;
        this.waitFunction = tx.wait;
        return receipt;
    }
    async wait(type, timeout) {
        if (!this.waitFunction)
            throw new Error("no wait function defined");
        return this.waitFunction(type, timeout);
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=Transaction.js.map