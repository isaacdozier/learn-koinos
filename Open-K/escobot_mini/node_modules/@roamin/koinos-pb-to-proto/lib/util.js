"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMessage = exports.getOneofs = exports.getField = exports.getFieldType = exports.getFieldLabel = exports.getbType = exports.getJSType = exports.getExtension = exports.getEnum = exports.getImport = exports.getPackage = exports.getSyntax = void 0;
const descriptor_pb_js_1 = require("google-protobuf/google/protobuf/descriptor_pb.js");
const optionspb = __importStar(require("./options_pb.js"));
function getSyntax(fileDesc) {
    return `syntax = '${fileDesc.getSyntax()}';\n\n`;
}
exports.getSyntax = getSyntax;
function getPackage(fileDesc) {
    return `package ${fileDesc.getPackage()};\n\n`;
}
exports.getPackage = getPackage;
function getImport(dependency) {
    return `import "${dependency}";\n\n`;
}
exports.getImport = getImport;
function getEnum(enumDesc) {
    const values = [];
    for (const value of enumDesc.getValueList()) {
        values.push(`${value.getName()} = ${value.getNumber()};`);
    }
    return `
enum ${enumDesc.getName()} {
  ${values.join('\n  ')} 
}\n\n`;
}
exports.getEnum = getEnum;
function getExtension(extDesc) {
    const optional = extDesc.hasProto3Optional() ? 'optional' : '';
    return `
extend ${extDesc.getExtendee()} {
  ${optional} ${extDesc.getTypeName()} ${extDesc.getName()} = ${extDesc.getNumber()};
}\n\n`;
}
exports.getExtension = getExtension;
function getJSType(options) {
    if (!options) {
        return '';
    }
    switch (options.getJstype()) {
        case descriptor_pb_js_1.FieldOptions.JSType.JS_NORMAL:
            return '';
        case descriptor_pb_js_1.FieldOptions.JSType.JS_NUMBER:
            return 'jstype = JS_NUMBER';
        case descriptor_pb_js_1.FieldOptions.JSType.JS_STRING:
            return 'jstype = JS_STRING';
        default:
            return '';
    }
}
exports.getJSType = getJSType;
function getbType(options) {
    if (!options) {
        return '';
    }
    // @ts-ignore btype is defined here
    switch (options.getExtension(optionspb.btype)) {
        // @ts-ignore
        case optionspb.bytes_type.BASE64:
            return '(koinos.btype) = BASE64';
        // @ts-ignore
        case optionspb.bytes_type.BASE58:
            return '(koinos.btype) = BASE58';
        // @ts-ignore
        case optionspb.bytes_type.HEX:
            return '(koinos.btype) = HEX';
        // @ts-ignore
        case optionspb.bytes_type.BLOCK_ID:
            return '(koinos.btype) = BLOCK_ID';
        // @ts-ignore
        case optionspb.bytes_type.TRANSACTION_ID:
            return '(koinos.btype) = TRANSACTION_ID';
        // @ts-ignore
        case optionspb.bytes_type.CONTRACT_ID:
            return '(koinos.btype) = CONTRACT_ID';
        // @ts-ignore
        case optionspb.bytes_type.ADDRESS:
            return '(koinos.btype) = ADDRESS';
        default:
            return '';
    }
}
exports.getbType = getbType;
function getFieldLabel(fieldDesc) {
    switch (fieldDesc.getLabel()) {
        case descriptor_pb_js_1.FieldDescriptorProto.Label.LABEL_REPEATED:
            return 'repeated';
        case descriptor_pb_js_1.FieldDescriptorProto.Label.LABEL_REQUIRED:
            return 'required';
        case descriptor_pb_js_1.FieldDescriptorProto.Label.LABEL_OPTIONAL:
            // in proto3, optional is not handled via label anymore
            return '';
        default:
            throw new Error(`Label '${fieldDesc.getLabel()}' is not supported`);
    }
}
exports.getFieldLabel = getFieldLabel;
function getFieldType(fieldDesc) {
    switch (fieldDesc.getType()) {
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_INT32:
            return 'int32';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_SINT32:
            return 'sint32';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_FIXED32:
            return 'fixed32';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_SFIXED32:
            return 'sfixed32';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_UINT32:
            return 'uint32';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_INT64:
            return 'int64';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_SINT64:
            return 'sint64';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_FIXED64:
            return 'fixed64';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_SFIXED64:
            return 'sfixed64';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_UINT64:
            return 'uint64';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_FLOAT:
            return 'float';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_DOUBLE:
            return 'double';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_BOOL:
            return 'bool';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_STRING:
            return 'string';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_BYTES:
            return 'bytes';
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_MESSAGE:
        case descriptor_pb_js_1.FieldDescriptorProto.Type.TYPE_ENUM:
            return fieldDesc.getTypeName();
        default:
            throw new Error(`Type '${fieldDesc.getTypeName()}' is not supported`);
    }
}
exports.getFieldType = getFieldType;
function getField(fieldDesc) {
    const fieldOptions = fieldDesc.getOptions();
    const fieldName = fieldDesc.getName();
    const fieldId = fieldDesc.getNumber();
    const optional = fieldDesc.hasProto3Optional() ? 'optional' : '';
    const jsType = getJSType(fieldOptions);
    const bType = getbType(fieldOptions);
    const extension = jsType ? `[${jsType}]` : bType ? `[${bType}]` : '';
    return `${optional} ${getFieldLabel(fieldDesc)} ${getFieldType(fieldDesc)} ${fieldName} = ${fieldId} ${extension};`;
}
exports.getField = getField;
function getOneofs(messageDesc, oneOfFields) {
    const result = [];
    for (const [index, oneofDesc] of messageDesc.getOneofDeclList().entries()) {
        const oneofName = oneofDesc.getName();
        if (oneOfFields[index]) {
            result.push(`
    oneof ${oneofName} {
      ${oneOfFields[index].join('\n    ')}
    }\n\n`);
        }
    }
    return result;
}
exports.getOneofs = getOneofs;
function getMessage(messageDesc) {
    const nestedMessages = [];
    const fields = [];
    const oneOfFields = [];
    // nested messages
    for (const nestedMessage of messageDesc.getNestedTypeList()) {
        nestedMessages.push(getMessage(nestedMessage));
    }
    // fields
    for (const fieldDesc of messageDesc.getFieldList()) {
        const field = getField(fieldDesc);
        if (fieldDesc.hasOneofIndex() && !fieldDesc.hasProto3Optional()) {
            const oneOfIndex = fieldDesc.getOneofIndex();
            if (oneOfIndex === undefined) {
                throw new Error('Missing one_of index.');
            }
            let existingFields = oneOfFields[oneOfIndex];
            if (existingFields === undefined) {
                existingFields = [];
                oneOfFields[oneOfIndex] = existingFields;
            }
            existingFields.push(field);
        }
        else {
            fields.push(field);
        }
    }
    // one_of fields
    const oneOfs = getOneofs(messageDesc, oneOfFields);
    return `
  message ${messageDesc.getName()} {
    ${nestedMessages.join('\n  ')}
    ${fields.join('\n  ')}
    ${oneOfs.join('\n  ')}
  }\n\n`;
}
exports.getMessage = getMessage;
